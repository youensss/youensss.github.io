<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Infix, Prefix, Postfix Notation | YOUENS Site</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://example.com/posts/infix-prefix-postfix-notation/">
<link rel="icon" href="../../ths.png" sizes="482x543">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><!-- Font Awesome --><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
<meta name="author" content="youens">
<link rel="prev" href="../ubuntu%E4%B8%8BHexo%2Bgithub%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0/" title="Ubuntu 下 Hexo + Github 建站笔记" type="text/html">
<link rel="next" href="../see-theory/" title="See theory" type="text/html">
<meta property="og:site_name" content="YOUENS Site">
<meta property="og:title" content="Infix, Prefix, Postfix Notation">
<meta property="og:url" content="https://example.com/posts/infix-prefix-postfix-notation/">
<meta property="og:description" content="1 Infix Notation
2 Prefix Notation
3 Postfix Notation
4 Conversion of Infix Expressions to Prefix and Postfix
4.1 Infix-to-Postfix Conversion
4.2 Postfix Evaluation
4.3 Infix-to-Prefix Conversion
4.4 ">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-10-14T09:57:59+08:00">
<meta property="article:tag" content="Python">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark
bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="../../">

            <span id="blog-title">YOUENS Site</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../../index.html" class="nav-link"></a>
                </li>
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Archives</a>
                </li>
<li class="nav-item">
<a href="../../categories/index.html" class="nav-link">Categories &amp; Tags</a>
                </li>
<li class="nav-item">
<a href="../../rss.xml" class="nav-link">RSS feed</a>

                
            </li>
</ul>
<form method="get" action="https://www.google.com/search" class="form-inline my-2 my-lg-0" role="search">
<div class="form-group">
<input type="text" name="q" class="form-control mr-sm-2" placeholder="Search">
</div>
<button type="submit" class="btn btn-secondary my-2 my-sm-0">
   <i class="fas fa-search"></i></button>

<input type="hidden" name="sitesearch" value="https://example.com/">
</form>


            <ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Infix, Prefix, Postfix Notation</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    youens
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2019-10-14T09:57:59+08:00" itemprop="datePublished" title="2019-10-14">2019-10-14</time></a>
            </p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div class="toc">
<ul>
<li><a href="#1-infix-notation">1 Infix Notation</a></li>
<li><a href="#2-prefix-notation">2 Prefix Notation</a></li>
<li><a href="#3-postfix-notation">3 Postfix Notation</a></li>
<li>
<a href="#4-conversion-of-infix-expressions-to-prefix-and-postfix">4 Conversion of Infix Expressions to Prefix and Postfix</a><ul>
<li><a href="#41-infix-to-postfix-conversion">4.1 Infix-to-Postfix Conversion</a></li>
<li><a href="#42-postfix-evaluation">4.2 Postfix Evaluation</a></li>
<li><a href="#43-infix-to-prefix-conversion">4.3 Infix-to-Prefix Conversion</a></li>
<li><a href="#44-prefix-evaluation">4.4 Prefix Evaluation</a></li>
</ul>
</li>
</ul>
</div>
<p>Infix, prefix and postfix notations are three equivalent ways of writing mathematical expressions. </p>
<h2 id="1-infix-notation">1 Infix Notation</h2>
<p>Infix notation is the most natural way we write mathematical expressions, as we use it every day. For example, $A+B$, which means a plus b. However, infix notation needs extra information to make the order of evaluation of the operators clear, in which case, means the arithmetic rules. An expression like $(A+B) \ast (C+D)$ means that we should do the two additions in the brackets first and then do the multiplication by the two results.</p>
<h2 id="2-prefix-notation">2 Prefix Notation</h2>
<p>When using prefix notation, the operator is written before their operands. For example, assume you want to convert the infix expression $(A+B) \ast (C+D)$ to prefix, the result is like this: $\ast +AB+CD$. In fact, we can add brackets to make this more explicit: $((A+B) \ast (C+D))$. As you can find, the operator of the two operands just moves to the left bracket in prefix expression.</p>
<h2 id="3-postfix-notation">3 Postfix Notation</h2>
<p>Contrary to the prefix notation, the operator is written after their operands in postfix expression. For example, infix expression $(A+B)\ast (C+D)$ should be writen as $AB+CD+ \ast$. If we use the same adding-brackets trick, you will find the operator of the operands moves to the right in postfix expression.</p>
<p>Though equivalent, infix, prefix and postfix notations have different application scenarios.</p>
<blockquote>
<p>Becasue infix notation is so common in mathematics, it is much easier to read, and so is used in most computer languages. However, prefix notation is often used for operators that take a single operand(e.g. negation) and function calls. Although postfix notation and prefix notation have similar complexity, postfix is slightly easier to evaluate in simple circumstances, such as in some calculators, as the operators really are evaluated strictly left-to-right.</p>
</blockquote>
<h2 id="4-conversion-of-infix-expressions-to-prefix-and-postfix">4 Conversion of Infix Expressions to Prefix and Postfix</h2>
<h3 id="41-infix-to-postfix-conversion">4.1 Infix-to-Postfix Conversion</h3>
<p>The basis for the algorithms goes like this:</p>
<ul>
<li>Initialize an empty list and stack.</li>
<li>Read the infix expression from left to right.</li>
<li>If an operand is encountered, add it to the list.</li>
<li>If a left parenthesis is encountered, add it to the stack.</li>
<li>If a right parenthesis is encountered, pop the stack until the corresponding left parenthesis is removed and append each operator to the list.</li>
<li>If an operator is encountered:</li>
<li>If the operator has a higher precedence over other operators in the stack, push it on the stack.</li>
<li>If the operator has a lower or equal precedence over other operators in the stack, pop the stack until the rest operators have a lower precedence. Append those operators poped to the list and push the operator on the stack.</li>
<li>Reached the end of the expression, pop everything in the stack and append them to the list.</li>
</ul>
<p>Here is the algorithm implementation in Python.</p>
<div class="code"><pre class="code literal-block"><span class="c1"># Define Stack class.</span>
<span class="k">class</span> <span class="nc">Stack</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>        

    <span class="k">def</span> <span class="nf">peak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">isEmpty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>

<div class="code"><pre class="code literal-block"><span class="k">def</span> <span class="nf">infixToPostfix</span><span class="p">(</span><span class="n">infixexpr</span><span class="p">):</span>
    <span class="n">prec</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'*'</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'/'</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'+'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'-'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'('</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span> <span class="c1"># Define the arthmetic precedence using a dict.</span>
    <span class="n">operator</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
    <span class="n">postfixList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tokenList</span> <span class="o">=</span> <span class="n">infixexpr</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenList</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">token</span> <span class="ow">in</span> <span class="s2">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span> <span class="ow">or</span> <span class="n">token</span> <span class="ow">in</span> <span class="s2">"0123456789"</span><span class="p">:</span>
            <span class="n">postfixList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s1">'('</span><span class="p">:</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s1">')'</span><span class="p">:</span>
            <span class="n">topToken</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">topToken</span> <span class="o">==</span> <span class="s1">'('</span><span class="p">:</span>
                <span class="n">postfixList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">topToken</span><span class="p">)</span>
                <span class="n">topToken</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="p">(</span><span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">prec</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">peak</span><span class="p">()]</span> <span class="o">&gt;=</span> <span class="n">prec</span><span class="p">[</span><span class="n">token</span><span class="p">]):</span>
                <span class="n">postfixList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
        <span class="n">postfixList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    <span class="k">return</span> <span class="s1">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">postfixList</span><span class="p">)</span>
</pre></div>

<h3 id="42-postfix-evaluation">4.2 Postfix Evaluation</h3>
<p>Here we will consider the evaluation of an expression which is already in postfix notation. The basis for the algorithm goes like this:</p>
<ul>
<li>Initialize an empty stack.</li>
<li>Read the postfix expression from left to right.</li>
<li>If a number is encountered, add it to the stack.</li>
<li>If an operator is encountered, pop two operands from the stack and do the corresponding operation. Push the result on the stack.</li>
</ul>
<p>Here is the algorithm implementation in Python.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span> <span class="nf">postfixEval</span><span class="p">(</span><span class="n">postfixExpr</span><span class="p">):</span>
    <span class="n">operandStack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
    <span class="n">tokenList</span> <span class="o">=</span> <span class="n">postfixExpr</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenList</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">token</span> <span class="ow">in</span> <span class="s2">"0123456789"</span><span class="p">:</span>
            <span class="n">operandStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">operand2</span> <span class="o">=</span> <span class="n">operandStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">operand1</span> <span class="o">=</span> <span class="n">operandStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">doMath</span><span class="p">(</span><span class="n">token</span><span class="p">,</span><span class="n">operand1</span><span class="p">,</span><span class="n">operand2</span><span class="p">)</span>
            <span class="n">operandStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">operandStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">doMath</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">"*"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">"/"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">/</span> <span class="n">op2</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">"+"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">-</span> <span class="n">op2</span>
</pre></div>

<h3 id="43-infix-to-prefix-conversion">4.3 Infix-to-Prefix Conversion</h3>
<p>The basis for the algorithms goes like this:</p>
<ul>
<li>Initialize an empty list and stack.</li>
<li>Reverse the infix expression and read it from left to right.</li>
<li>If an operand is encountered, add it to the list.</li>
<li>If a right parenthesis is encountered, add it to the stack.</li>
<li>If a left parenthesis is encountered, pop the stack until the corresponding left parenthesis is removed and append each operator to the list.</li>
<li>If an operator is encountered:</li>
<li>If the operator has a higher or equal precedence over other operators in the stack, push it on the stack.</li>
<li>If the operator has a lower precedence over other operators in the stack, pop the stack until the rest operators have a lower or equal precedence. Append those operators poped to the list and push the operator on the stack.</li>
<li>Reached the end of the expression, pop everything in the stack and append them to the list.</li>
<li>Reverse the list.</li>
</ul>
<p>Here is the algorithm implementation in Python.</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span> <span class="nf">infixToPrefix</span><span class="p">(</span><span class="n">infixexpr</span><span class="p">):</span>
    <span class="n">prec</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'*'</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'/'</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'+'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'-'</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">')'</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span> <span class="c1"># Define the arthmetic precedence using a dict.</span>
    <span class="n">operator</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
    <span class="n">prefixList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tokenList</span> <span class="o">=</span> <span class="n">infixexpr</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">tokenList</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenList</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">token</span> <span class="ow">in</span> <span class="s2">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span> <span class="ow">or</span> <span class="n">token</span> <span class="ow">in</span> <span class="s2">"0123456789"</span><span class="p">:</span>
            <span class="n">prefixList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s1">')'</span><span class="p">:</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="s1">'('</span><span class="p">:</span>
            <span class="n">topToken</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">topToken</span> <span class="o">==</span> <span class="s1">')'</span><span class="p">:</span>
                <span class="n">prefixList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">topToken</span><span class="p">)</span>
                <span class="n">topToken</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="p">(</span><span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">prec</span><span class="p">[</span><span class="n">operator</span><span class="o">.</span><span class="n">peak</span><span class="p">()]</span> <span class="o">&gt;</span> <span class="n">prec</span><span class="p">[</span><span class="n">token</span><span class="p">]):</span>
                <span class="n">prefixList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">operator</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">():</span>
        <span class="n">prefixList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    <span class="n">prefixList</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">return</span> <span class="s1">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">prefixList</span><span class="p">)</span>
</pre></div>

<h3 id="44-prefix-evaluation">4.4 Prefix Evaluation</h3>
<p>The algorithms for prefix evaluation is almost like postfix.</p>
<ul>
<li>Reverse the prefix expression.</li>
<li>If a number is encountered, push it on the stack.</li>
<li>If a operator is encountered, pop two operands from the stack and do the corresponding operation. Push the result on the stack.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="k">def</span> <span class="nf">prefixEval</span><span class="p">(</span><span class="n">prefixExpr</span><span class="p">):</span>
    <span class="n">operandStack</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>
    <span class="n">tokenList</span> <span class="o">=</span> <span class="n">prefixExpr</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">tokenList</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokenList</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">token</span> <span class="ow">in</span> <span class="s2">"0123456789"</span><span class="p">:</span>
            <span class="n">operandStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">operand1</span> <span class="o">=</span> <span class="n">operandStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">operand2</span> <span class="o">=</span> <span class="n">operandStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">doMath</span><span class="p">(</span><span class="n">token</span><span class="p">,</span><span class="n">operand1</span><span class="p">,</span><span class="n">operand2</span><span class="p">)</span>
            <span class="n">operandStack</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">operandStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">doMath</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">"*"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">"/"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">/</span> <span class="n">op2</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">"+"</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op1</span> <span class="o">-</span> <span class="n">op2</span>
</pre></div>

<p><strong>References</strong></p>
<ul>
<li>http://www.cs.man.ac.uk/~pjj/cs212/fix.html</li>
<li>https://runestone.academy/runestone/books/published/pythonds/BasicDS/InfixPrefixandPostfixExpressions.html</li>
</ul>
</div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../categories/python/" rel="tag">Python</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../ubuntu%E4%B8%8BHexo%2Bgithub%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0/" rel="prev" title="Ubuntu 下 Hexo + Github 建站笔记">Previous post</a>
            </li>
            <li class="next">
                <a href="../see-theory/" rel="next" title="See theory">Next post</a>
            </li>
        </ul></nav></aside><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script><script>
                renderMathInElement(document.body,
                    {
                        
delimiters: [
     {left: "$$", right: "$$", display: true},
     {left: "\\[", right: "\\]", display: true},
     {left: "\\begin{equation*}", right: "\\end{equation*}", display: true},
     {left: "$", right: "$", display: false},
     {left: "\\(", right: "\\)", display: false}
]

                    }
                );
            </script></article><!--End of body content--><footer id="footer">
            Contents © 2022         <a href="mailto:youensss@foxmail.com">youens</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
